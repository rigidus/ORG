:PROPERTIES:
:ID:       be5c5c92-4b7a-4bec-a3a6-ded027457127
:END:
#+title: GoFFI

#+STARTUP: showall indent hidestars

Существует несколько вариантов ускорить вычисления за счет низкоуровневого программирования:
- Вынести вычисление в отдельный процесс, написанный на низкоуровневом языке и обмениваться с ним данными
  - через Memory mapped files
  - через socket или pipe
  - через очередь
- Писать низкоуровневый код так чтобы он становился частью GO-бинарника.
  - На языке Си
  - На языке Си с ассемблерными вставками
  - На чистом ассемблере с подключением во время линковки
  - На языке Go-ассемблера

Первый способ выглядит более простым, но череват затратами на межпроцессную коммуникацию, поэтому я начну исследовать с более сложного второго.

Также существует проект https://github.com/minio/c2goasm который позволяет преобразовать ассемблерные .s файлы в Go-ассемблерные. Он показывает, как сишные функции с интрисинками могут быть преобразованы в Go-ассемблер.

* DONE How to get go assembly code of my Go-program

Let's start with GoLang helloworld:

#+BEGIN_SRC go
  // main.go
  package main

  import (
      "fmt"
  )

  func main() {
      fmt.Println("Hello World!")
  }
#+END_SRC

Build it:

#+BEGIN_SRC sh
  # Generates obj file as main.o
  go tool compile main.go

  # Generates assembly, and sends it to a new main.asm
  go tool compile -S main.go > main.asm

  # Specials:
  GOOS=linux GOARCH=amd64 go tool compile -S main.go > main.asm
  # or:
  go build -gcflags -S main.go
#+END_SRC

Now we have main.asm with go assembly

* START How to compile and call C-function from Go

** Simple variant

Если сделать import "C", то комментарий, который идет перед ним будет скомпилирован как си-код и включен в сборку.

#+BEGIN_SRC go
  package main

  //int pt(){
  // return 1;
  //}
  import "C"
  import "fmt"

  func main() {
      fmt.Println(C.pt())
  }
#+END_SRC

build:

#+BEGIN_SRC sh
  env CGO_ENABLED=1 GOOS=linux go build test.go
  # variant with linking .o file:
  # CGO_ENABLED=1 GOOS=linux go build -buildmode=plugin -o path/to/module.so test.go
#+END_SRC

** Extended variant

Таким образом можно сделать ~#include~ чтобы прилинковать сишную библиотеку и вызывать её функции. Туда же можно поместить флаги для компиляции.

#+BEGIN_SRC go :tangle ./cgo-examples/main.go :noweb yes
  package main

  /*
     #cgo CFLAGS: -I${SRCDIR}/ctestlib
     #cgo LDFLAGS: -Wl,-rpath,${SRCDIR}/ctestlib
     #cgo LDFLAGS: -L${SRCDIR}/ctestlib
     #cgo LDFLAGS: -ltest

     #include <test.h>
  ,*/
  import "C"
  import (
      "bytes"
      "fmt"
      "unsafe"
  )

  <<go_decl>>

  func main() {
      <<go_call>>
  }
#+END_SRC

Example of Makefile

#+BEGIN_SRC sh
  .PHONY: all c go run env

  TESTLIBPATH="./ctestlib"

  all: c go run

  env:
      docker build --tag cgo .
      docker run --rm -ti -v $(shell pwd):/src cgo

  c:
      gcc -c -Wall -Werror -fpic -o ${TESTLIBPATH}/test.o ${TESTLIBPATH}/test.c
      gcc -shared -o ${TESTLIBPATH}/libtest.so ${TESTLIBPATH}/test.o

  go:
      go build -o app *.go

  run:
      ./app
#+END_SRC

Сишный код, который станет библиотекой

#+BEGIN_SRC c :tangle ./cgo-examples/ctestlib/test.c :noweb yes
  #include "test.h"

  <<c_code>>
#+END_SRC

и h-файл к нему

#+BEGIN_SRC c :tangle ./cgo-examples/ctestlib/test.h :noweb yes
  #ifndef _TESTLIB_H_
  #define _TESTLIB_H_

  #include <stdio.h>
  #include <stdlib.h>

  <<h_code>>

  #endif
#+END_SRC

*** Sum

Сначала пусть просто функция, которая демонстрирует выполнение вычислений в си-коде:

#+BEGIN_SRC c :noweb-ref h_code
  int sum(int a, int b);
#+END_SRC

#+BEGIN_SRC c :noweb-ref c_code
  int sum(int a, int b) {
      return a + b;
  }
#+END_SRC

#+BEGIN_SRC go :noweb-ref go_call
  fmt.Println("\nNumbers")
  a := 1
  b := 2
  sum := int(C.sum(C.int(a), C.int(b)))
  fmt.Print(sum, "\n\n")
#+END_SRC

*** Get string

Теперь получим константную строку из си-кода

#+BEGIN_SRC c :noweb-ref h_code
  const char* get_string();
#+END_SRC

#+BEGIN_SRC c :noweb-ref c_code
  const char* get_string() {
      return "string sent from C";
  }
#+END_SRC

#+BEGIN_SRC go :noweb-ref go_call
  fmt.Println("Get string")
  getString := C.GoString(C.get_string())
  fmt.Println(getString)
  stringBytes := C.GoBytes(unsafe.Pointer(C.get_string()), 24)
  fmt.Println(stringBytes[0:bytes.Index(stringBytes, []byte{0})])
  fmt.Println()
#+END_SRC

*** Send string to C

Печать переданной из Go строки в сишном коде

#+BEGIN_SRC c :noweb-ref h_code
  void print_string(char* a);
#+END_SRC

#+BEGIN_SRC c :noweb-ref c_code
  void print_string(char* a) {
      printf("string sent from Go: %s\n", a);
  }
#+END_SRC

#+BEGIN_SRC go :noweb-ref go_call
  fmt.Println("Send string")
  str := "lorem ipsum"
  cStr := C.CString(str)
  C.print_string(cStr)
  C.free(unsafe.Pointer(cStr))
  fmt.Println()
#+END_SRC

*** Send buffer to C

Печать строки, которая была передана из Go-кода

#+BEGIN_SRC c :noweb-ref h_code
  void print_buffer(unsigned char *buf, size_t size);
#+END_SRC

#+BEGIN_SRC c :noweb-ref c_code
  void print_buffer(unsigned char *buf, size_t size) {
      for (uint i = 0; i < size; i++) {
          printf("%X", buf[i]);
      }
      printf("\n");
  }
#+END_SRC

#+BEGIN_SRC go :noweb-ref go_call
  fmt.Println("Send byte array")
  data := []byte{1, 4, 2}
  cBytes := (*C.uchar)(unsafe.Pointer(&data[0]))
  cBytesLength := C.size_t(len(data))
  fmt.Print("bytes: ")
  C.print_buffer(cBytes, cBytesLength)
  fmt.Println()
#+END_SRC

*** Struct

Работа со структурами, объявленными в си-коде

#+BEGIN_SRC c :noweb-ref h_code
  typedef struct point
  {
      int x;
      int y;
  } point;

  int point_diff(point p);
#+END_SRC

#+BEGIN_SRC c :noweb-ref c_code
  int point_diff(point p) {
      return p.x - p.y;
  }
#+END_SRC

#+BEGIN_SRC go :noweb-ref go_call
  fmt.Println("Get and pass struct")
  point := C.struct_point{}
  point.x = 0
  point.y = 2
  fmt.Println(point)
  fmt.Print(C.point_diff(point), "\n\n")
#+END_SRC

*** Arbitrary data: unsafe.Pointer to void pointer

Передача void-указателя

#+BEGIN_SRC c :noweb-ref h_code
  void pass_void_pointer(void *ptr);
#+END_SRC

#+BEGIN_SRC c :noweb-ref c_code
  void pass_void_pointer(void *ptr) {
      printf("%d\n", *((int*)ptr));
  }
#+END_SRC

#+BEGIN_SRC go :noweb-ref go_call
  fmt.Println("Pass void pointer")
  C.pass_void_pointer(unsafe.Pointer(&point.y))
  fmt.Println()
#+END_SRC

*** Enum

#+BEGIN_SRC c :noweb-ref h_code
  enum status {
      PENDING,
      DONE,
  };
#+END_SRC

#+BEGIN_SRC go :noweb-ref go_decl
  type Status int

  const (
      Pending Status = iota
      Done
  )
#+END_SRC


#+BEGIN_SRC go :noweb-ref go_call
  fmt.Println("Access enum")
  fmt.Print(C.enum_status(Pending) == C.PENDING, C.PENDING, C.DONE, "\n\n")
#+END_SRC

*** Callback

Мы хотим вызвать гошный коллбэк ~evenNumberCallback~ из сишного
кода. Для этого мы будем использовать следующую последовательность
действий:
- регистрируем коллбэк в гошной функции ~registerCallback~, она
  возвращает нам индекс коллбэка
- вызываем сишную функцию ~generate_numbers~, передавая ей индекс
  коллбека. Она:
  - вызывает гошную функцию ~evenNumberCallbackProxy~ (несколько раз)
    передавая ей номер коллбэка. Она:
    - получает коллбэк по его номеру, вызывая гошную функцию
      ~getCallback~, которая возвращает указатель на коллбэк.
    - вызывает коллбэк по этому указателю и возвращается
  - возвращается
- удаляем зарегитированный коллбэк

#+BEGIN_SRC go :noweb-ref go_call
  fmt.Println("Pass callback")
  c := registerCallback(evenNumberCallback, nil)
  C.generate_numbers(5, c)
  unregisterCallback(c)
#+END_SRC

Начнем с сишной функции ~generate_numbers~, оставив более простую
регистрацию и удаление коллбэка на потом. В ней надо объявить
~evenNumberCallbackProxy~, которая по-видимому станет внешним
(external) символом, что (по моим догадкам) позволит линкеру
слинковать этот символ с гошной функцией, и таким образом сделать ее
доступной для вызова.

#+BEGIN_SRC c :noweb-ref c_code
  void generate_numbers(uint num, uint callback) {
      void evenNumberCallbackProxy(uint, int);

      for (uint i = 0; i <= num; i++) {
          if (i % 2 == 0) {
              evenNumberCallbackProxy(callback, i);
          }
      }
  }
#+END_SRC

Также не забыть объявить ~generate_numbers~ в заголовочном файле:

#+BEGIN_SRC c :noweb-ref h_code
  void generate_numbers(uint num, uint callback);
#+END_SRC

Теперь нужно написать го-функцию ~evenNumberCallbackProxy~,
объявив ее символ экспортируемым:

#+NAME: even_number_callback_proxy
#+BEGIN_SRC go
  //export evenNumberCallbackProxy
  func evenNumberCallbackProxy(i C.uint, num int) {
      c := getCallback(index(i))
      c.callback.(func(int))(num)
  }
#+END_SRC

Эта функция использует неэкспортируемую функцию ~getCallback~, которая
для потокобезопасности должна использовать мьютекс:

#+NAME: get_сallback
#+BEGIN_SRC go
  func getCallback(i index) *callback {
      mutex.Lock()
      defer mutex.Unlock()
      return storage[i].(*callback)
  }
#+END_SRC

Так как ей требуется ~storage~ и ~mutex~ мы должны объявить их:

#+NAME: var_storage_mutex
#+BEGIN_SRC go
  var (
      storage = make(store)
      mutex   sync.Mutex
  )
#+END_SRC

Используемый тип ~store~ - это просто хэшмапа, в которой ключи - это
индексы (=uint8), значения - интерфейсы. Заодно тут же определим коллбэк, как структуру, в которой есть указатель на аргумент

#+NAME: type_index_store_callback
#+BEGIN_SRC go
  type (
      index    uint8
      store    map[index]interface{}
      callback struct {
          callback interface{}
          arg      unsafe.Pointer
      }
  )
#+END_SRC

Теперь можно вернуться к регистрации и удалению коллбэка. Эти функции
тоже для потокобезопасности используют мьютексы:

#+NAME: register_unregister_callback
#+BEGIN_SRC go
  func registerCallback(c interface{}, arg unsafe.Pointer) C.uint {
      mutex.Lock()
      i := index(len(storage))
      storage[i] = &callback{
          callback: c,
          arg:      arg,
      }
      mutex.Unlock()

      return C.uint(i)
  }

  func unregisterCallback(i C.uint) {
      mutex.Lock()
      delete(storage, index(i))
      mutex.Unlock()
  }
#+END_SRC

Осталось собрать все гошные функции в файл proxy.go

#+BEGIN_SRC go :tangle ./cgo-examples/proxy.go :mkdirp yes :noweb yes
  package main

  import "C"
  import (
      "sync"
      "unsafe"
  )

  <<type_index_store_callback>>

  <<var_storage_mutex>>

  <<even_number_callback_proxy>>

  //export userCallbackProxy
  func userCallbackProxy(i C.uint) {
      c := getCallback(index(i))
      c.callback.(func(unsafe.Pointer))(c.arg)
  }

  <<register_unregister_callback>>

  <<get_сallback>>

#+END_SRC

*** Callback with params

Шаги:
- начальная иницализация гошной структуры ~user~
- регистрируем коллбэк, при регистрации передаем указатель на
  ~user~. Этот указатель сохраняется в коллбеке. Возвращаемое
  значение - индекс коллбэка - запоминаем.
- вызываем сишную функцию ~user_action~, передавая ей индекс
  коллбэка. Она:
  - вызывает гошную функцию ~userCallbackProxy~ (несколько раз) передавая ей номер коллбэка. Она:
    - получает коллбэк по его номеру
    - вызывая коллбек с аргументом, который взят из структуры ~user~, которая получена из структуры коллбэка.
    - возвращается
  - возвращается
- удаляем коллбэк
- печатаем ~user~

#+NAME: todo
#+BEGIN_SRC go :noweb-ref go_call
  user := User{
      Username: "johndoe",
  }
  cWithParams := registerCallback(userCallback, unsafe.Pointer(&user))
  C.user_action(cWithParams)
  unregisterCallback(cWithParams)
  fmt.Println(user)
#+END_SRC

Начнем с сишной функции ~user_action~.

#+BEGIN_SRC c :noweb-ref c_code
  void user_action(uint callback) {
      void userCallbackProxy(uint);

      for (int i = 0; i < 5; i++) {
          userCallbackProxy(callback);
      }
  }
#+END_SRC

Также не забыть объявить ~user_action~ в заголовочном файле:

#+BEGIN_SRC c :noweb-ref h_code
  void user_action(uint callback);
#+END_SRC

~userCallbackProxy~ уже написан в предыдущем разделе и объявлен
экспортируемым.

#+BEGIN_SRC go :noweb-ref go_decl
  type User struct {
      Username string
      Visits   int
  }

  func evenNumberCallback(num int) {
      fmt.Println("odd number: ", num)
  }

  func userCallback(user unsafe.Pointer) {
      u := (*User)(unsafe.Pointer(user))
      u.Visits++
  }
#+END_SRC

*** TODO Intrisincs
* TODO How I can see assembly code for only one my functions
* TODO How I can wrote assebly functions and call it from GO?
* TODO How I can call GO-function and use GO-data from my assembly code?

Если в пакете есть какие-либо файлы ~.s~, то ~go build~ укажет
компилятору создать специальный заголовок с именем ~go_asm.h~, который
файлы ~.s~ могут затем ~#include~.

Файл содержит символические константы #define для смещений полей
структуры Go, размеры типов структур Go и большинство объявлений
констант Go, определенных в текущем пакете. При сборке Go следует
избегать предположений о компоновке типов Go и вместо этого
использовать эти константы. Это улучшает читаемость кода сборки и
сохраняет его устойчивость к изменениям.

Константы имеют вид ~const_name~. Например, учитывая объявление

#+BEGIN_SRC go
  const bufSize = 1024
#+END_SRC

ассемблерный код может ссылаться на значение этой константы как
~const_bufSize~.

Смещения полей имеют вид ~type_field~. Размеры структуры имеют вид
type__size. Например, рассмотрим следующее определение Go:

#+BEGIN_SRC go
  type reader struct {
      buf [bufSize]byte
      r   int
  }
#+END_SRC

Ассемблер может ссылаться на размер этой структуры как на
~reader__size~, а смещения двух полей как на ~reader_buf~ и
~reader_r~. Следовательно, если регистр ~R1~ содержит указатель на
reader, ассемблер может ссылаться на поле ~r~ как ~reader_r(R1)~.

Если любое из этих #define имен неоднозначно (например, структура с
полем _size), #include "go_asm.h" завершится ошибкой с ошибкой
"redefinition of macro"

детали в Quick guide to Go's Assembler.

* Notices

  The FUNCDATA and PCDATA directives contain information for use by
  the garbage collector; they are introduced by the compiler.

* Links

  https://pkg.go.dev/cmd/cgo
  https://go.dev/doc/asm
  https://github.com/andreiavrammsd/cgo-examples
